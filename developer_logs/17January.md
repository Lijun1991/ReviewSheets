# January, 2017

### January 1st 2017 - ls, push swap

I have 7 days an 16 hours exactly to get finish ls and push_swap. that means resource management is going to break or make this thing. first thing i have to do is plot my sunk time. i will be posting sunk time in every entry. 

* wednesday, january 4th
	* meet john
		* early afternoon
		* at least 2 hours
	* moonlight
		* secure equipment at 5:00pm
		* start at 8:30pm
		* at least 2 hours

Next I need to minimize my time doing everything else. that means i have to get my hands on soylent as fast as possible, to kill meal time. money is no object here. this challenge will be made or broken 15-20 minutes at a time. i have to recognize that and adapt. 

* things i can do to cut maintenance time
	* soylent
		* how much needed?
			* guess 8 per day
				* 56
			* people to ask
				* lou
				* matt
				* not sure
			* order boxes now so you can get people back i.e. restock the global supply
				* 144 ordered
		* expected time savings
			* 14 - 20 hours
	* spartan shower
		* set timer
			* 2 minutes
	* spartan wake up
		* immediately
	* no unessary trips to places
		* forget something at dorm?
			* leave it
		* get mail and talk to bocal peeps simultaniously
			* use slack if at all possible
	* hold bathroom until needed
		* if unsure if needed default to wait
	* time all breaks with timer
		* don't set a limit to them, but have a big ass timer
	* time conversations with people
		* appropiate time for topic
	* go to bed exhausted
		* time of day no longer matters
		* if you are uncertain whether you will be able to fall asleep in less than 15 minutes
			* it's not time to sleep yet
	* attempt to limit sleep to 6 - 7 hours
		* if you wake up for any reason you are up

That should buy me between 20 - 25 hours, which is a whole day if you think about it, comfort is expensive. now i need to manage my work time. any non-42 work should be minimized to the greatest degree possible. for this non-42 i should purposefully add delays since the amount of work to be done = 1, and the throughput is time allocated to doing it, i.e. if i do more faster i will get more faster, with a marginal profit. this is something i rarely care about since doing the work is the prize mostly, however in a situation like this it matters. non-42 work that is limited in scope log add no delay.

I will have a differing ability to do different work based on my acuity levels, which over time awake AND over the course will drop, as sleep deprivation starts to show it's effect. with will power i can manually keep myself on task for only so long eventually the needs of my body will take over. to categorize work types and matching actuity levels. if any inspiration strikes at any point, ride it.

* work type && times
	* high acuity
		* large amount of creative and analytical thinking
		* non-linear processing
		* edit mental scaffold
		* flow required

	* medium acuity
		* mild analytical thinking
		* linear processing
		* make small extensions to mental scaffold
		* flow not required

	* low acuity
		* little to no analytical thinking
		* no processing
		* follow mental scaffold
		* lol flow

* examples of work
	* high acuity
		* designing
			* including designing a research track
		* architecting
		* philisophical discovey
		* algorithm manipulation(because of lack of experience)
		* free-form coding
		* orating

	* medium acuity
		* managing resources (because of massive amounts of experience)
		* following research track
		* non free-form coding (because of experience this is only mild acuity)
			* interacting with logic not just symbols
		* meeting with creation of action items (because of experience)

	* low acuity
		* the manual part of manual labor
		* maintenance
		* coding
			* interacting with just symbols like math functions
			* this includes norming code
		* meeting communication of information (because of experience) 

before doing any work plan it and classify it, then manage it. before reaching low acuity state plan the high acuity work of the next day.

there are of course ways to force a high acuity state with things like adderall. only worth it if you have a particular deadline, someone helping you with task control 
(internals will be unreliable), and a recovery time from high acuity work aferwards. 

lets plan today. unfortunately i have used a bit of high acuity creating above framework. However since it will allow me to do serious management in a medium acuity state it's worth it. as the week goes by i will spending a larger amount of time in a low acuity state, high acuity spans will get shorter fast, and medium will slope down. this is cause by exhaustian. the high acuity work that needs to get done in the end of the week must be shifted to now since it is possible that i wont have the ability to do it at the end of the week. it's also vital that the high acuity work is accurate, so i must take my time with it. one major mistake and my chances of success go from possible to unlikely. 

one week. two projects. let's go.

* high acuity work in sight
	* grok ls man
	* design research track
	* architect ls
		* design for -R
	* design push_swap algorithm
		* likely needs to be down multiple times

* medium acuity work in sight
	* build push_swap architecture
	* design a algorithm swapping module for push_swap
	* acutally research ls
	* build ls architecture
	* respond to jamie response
	* contact Dima

* low acuity work in sight
	* do dishes
	* moonlight
		* secure equipment
	* chill with john
	* norm push_swap
	* norm ls
	* coding the operations of push_swap

the exp required to be lvl 5 is between 747 and 750 if i submit both programs with 100 i will be at 713. that means i will be short between 34 and 37 points to be lvl 5. i need to do one exam and have a shit ton of bonuses for push_swap and ls. corrector selection here will be key. 

* sunday, january, 1st 2017
	* high acuity
		* grok ls man
		* design research track
	* medium acuity work
		* build push_swap architecture
		* plan next day
	* low acuity work
		* do dishes
	
i'm exhausted. time to plan for tomorrow. 

* monday, january, 2ns 2017
	* high acuity
		* design the research track
	* medium acuity
		* continue with push_swap architecture
		* research ls
		* plan next day
	* low acuity
		* clean up the room a little cause charlie is coming with Mia and it will make him happy

* what i did today
	* setup planning structure
	* determined likelyhood of success
		* it's real low
	* talked and learned a little about ls
		* perror can handle ls's errors
	* talked to philip
		* found out about ecuity possibility
		* possible funding
	* worked on push_swap architecture
	* dicked around making up my mind
	* started groking ls

### January, 2nd, 2017

didn't sleep much. have to deal with it, that's life. bright side is my soylent is getting here hopefully within 2 days.

my prior commitments for the week

* wednesday, january 4th
	* meet john
		* early afternoon
		* at least 2 hours
	* moonlight
		* secure equipment at 5:00pm
		* start at 8:30pm
		* at least 2 hours

my priorities for today (thank you past oliver)

* monday, january, 2ns 2017
	* high acuity
		* ~design the research track~
	* medium acuity
		* continue with push_swap architecture
		* research ls
		* stack sorting paper
		* plan next day
	* low acuity
		* clean up the room a little cause charlie is coming with Mia and it will make him happy

So i need to design the research track first.

first i need to expose my current unknowns. 

* the allowed functions i don't know
	* opendir
	* readdir
	* closeddir
	* stat
	* lstat
	* getpwuid
	* getgrgrid
	* listxattr
	* time
	* ctime
	* readlink
	* perror
	* strerror

these need to all be researched. i also need to look into what the whole devices thing means.
research track seed is done. now on to continuing push_swap.

how do i want my algorithm infastructure to work? how about i have an array of algorithms to run, and then i can select or increment which one i want to run depending on a condition, this also gives me the flexibility of running both. I should also use of having a presorted version of the list to compare against. then i should have a structure that holds the pre sorted version of the list as well as the current best algorithm index, instruction count, and matching instruction list. to save on line count i should also have a structure that contains both my stacks and their respective sizes. my condition should be in an array as well and it should be a function, this will allow me to change the kind of conditions i change my array on very easily. i should return a number that will represents the index in the algorithm array to run the proper algorithm from my condition function.

* ~s_result struct~
	* `int*` true_sort
	* `char*` op_list
	* `size_t` op_count
	* `int` algo_index

* ~s_stack struct~
	* `int*` arr;
	* `int*` brr;
	* `size_t` asize;
	* `size_t` bsize;

* algorithm infastructure
	* ~presort the list with a sorting algorithm and save it to result structure~
		* find an algorithm to use
			* merge sort
		* implement the algorithm
	* array of algorithms to run
		* each algorithm function returns a `str*` representing the sorted instruction list			
	* select or increment desired algorithm based on a condition function
		* condition come from a function array of condition functions
			* each condition function returns the index to decide which algorithm to run
	* set the `s_result` solution to the return value of the algorithm if the number of `\n` is smaller than the currently stored verion

alright made good head way on the push_swap component. i'm burnt out on it though, so i should move on to the checker component. actually no. i can do that after dinner. lets do some research instead first.

[holy shit streams are awesome](http://www.gnu.org/software/libc/manual/html_node/I_002fO-on-Streams.html#I_002fO-on-Streams)! thank you GNU.





