# day10


#### questions 

* what are makefiles really?

#### explore

* compilation problematic 
	* so far used gcc 
		* gcc is a complex compiler 
		* makefile a tool to ease complex compilations 

* makefiles introduction 
	* `make` 
		* make files describe using rules how to compile program 
		* usually one rule at a time 
	
* makefiles 
	* Makefiles always start with Captial 
	* rules
		* syntax 
			* name, list of dependencies, description of rule 
		* when a Makefile is executed each command is displayed before execution 
			* to supress put @ sign before command 
		* example: 
			* print to screen 
			```
				rule_a:
					echo "rule A"
			```
			* print to screen with dependency  
			```
				rule_a:
					echo "rule A"
				rule_b: rule_a
					echo "rule B"
			```
	* variables 
		* doing variable thigns 
		* syntax 
			* name, equal sign, definition of variable 
			* variables are capital letters 
		* example: 
			```
				TEXT = "42 is for the braves"
			
				rule_a: 
					echo $(TEXT)
			```
	* complete example:
		* create a program
		* example: 
			```
				NAME = awesomeprog
				SRC = source.c

				all: $(NAME)

				$(NAME):
					gcc -o $(NAME) $(SRC)
				
				clean: 
					/bin/rm -f *.o

				fclean: clean
					/bin/rm -f $(NAME)

				re: fclean all
			 ```

* pointers to functions 
	* syntax 
		* example:
			* pseudo code
			```
				int x;
				int *y;
				
				void f(char c);

				void (*funptr)(char);
			```
			* putchar 
			```
				#include <unistd.h> 
				
				typedef void (*funptr)(char);
	
				void ft_putchar(char c)
				{
					write(1, &c, 1);
					return ;
				}
				
				int main()
				{
					funptr f;

					f = &ft_putchar;
					f('z');

					return (0);
				}
			```
	* example: 
		* in pseudo code
		* initial
		 ```
		 	- put_stdout 	-> write to stdout
			- put_file 		-> write in file 
			- put_network 	-> write on the network 
		
			function put( where, what )
			{
				if ( where == STDOUT ) 
					put_stdout( what );
				else if ( where == FILE )
					put_file( what );
				else if ( where == NETWORK )
					put_network( what );
				else
					error();
			}
		```
		* optimized 
		```
			- put_stdout	-> write to stdout
			- put_file		-> write to file 
			- put_network	-> write to network

			fun_tab = [ (STDOUT, &put_stdout );
						(FILE, 	 &put_file   );
						(NETWORK, &put_network); ]
			
			function put( where, what )
			{
				for ( where_r, put_function ) in fun_tab
				{
					if ( where == where_r )
						put_function( what );

			}
		```
	* conclusion 


* makefile 
	* introduction 
		* you need a Makefile to tell `make` what to do 	
			* usually used to tell `make` how to compile and link a program 
		* when `make` recompiles each changed C source must be recompild, if header have changed each C source file that includes the header file must be recompiled
		* each compilation produces an object file corresponding to a source file 
			* if any source file has been recompiled all the object files must be linked together 
	* what a rule looks like 
		* rule 
			* explain how and when to remake certain files which are the targets of the particular rule
				* `make` carries out the commands on the prerequisite to create or update the target 
		* the shape 
		```	
			target ... : prerequisites ...
				command
				...
				...
		```
		* target
			* the name of the action to be carried out, an identifier
				* a target is usually the name of a file that is generated by a program 
					* executables, object files 
		* prerequisite 
			* a target that is used as an input to create the target 
				* common for their to be heavy dependencies 
			* command 
				* an action that `make` carries out 
					* you must put a tab character at the beginning of every command line 
	* a simple makefile 
		* example setup- a executable file `edit` depends on eight object files which in turn depend on eight C source and three header files 
			* all the C files include `defs.h` but only those defining editing commands include `command.h`, only low level files that change the editor buffer include `buffer.h` 
		```
			edit: main.o kbd.o command.o display.o insert.o search.o files.o utils.o
				cc -o edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o

			main.o : main.c defs.h
				cc -c  main.c
			kbd.o : kbd.c defs.h command.h 
				cc -c command.c 
			command.o : command.c defs.h command.h 
				cc -c command.c
			display.o : dislpay.c defs.h buffer.h 
				cc -c display.c 
			insert.o : insert.c defs.h buffer.h
				cc -c insert.c 
			search.o : search.c defs.h buffer.h 
				cc -c search.c 
			files.o : files.c defs.h buffer.h 
				cc -c files.c 
			utils.o : utils.c defs.h
				cc -c utils.c
			clean : 
				rm edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o
		```
		* to use makefile to create the executable called edit 
			* `$ make` 
		* to use make file to delete the executable and all the objects files from the directory
			* `make clean` 
		* when a target is a file it needs to be recompiled or relinked if any of its prerequisites change 
			* prerequisites that are themselves automatically generated should be updated first 
		* a shell command follows each line that contains a target and prerequisite
			* these shell commands say how to update the target file 
		* targets that do not refer to files are called phony targets 
	* how `make` processes a makefile 
		* `make` starts with the first target 
			* this is called the default goal 
				* Goals are the targets that `make` strives ultimately to update 
		* in the previous example `edit` was the default goal so we put that rule first 
		* when you execut the `make` command
			* `make` reads the Makefile in the current directory and begins by processing the first rule 
				* in the example the rule is relinking `edit` 
			* before make can process the rule it must process the dependencies 
			* if any object file is newer than the `edit` executable then it is relinked 
	* variables make Makefiles simpler 
		* convention to have a variable named OBJECTS to list all object file names 
		* optimized code: 
		```
			OBJECTS	 = main.o kbd.o command.o display.o insert.o search.o files.o utils.o

			edit : $(objects) 
				cc -o edit $(objects) 
			main.o : main.c defs.h
				cc -c main.c 
			kbd.o : kbd.c defs.h command.h
				cc -c kbd.c
			command.o : command.c defs.h command.h
				cc -c command.c 
			display.o : display.c defs.h buffer.h
				cc -c display.c 
			insert.o : insert.c defs.h buffer.h 
				cc -c insert.c
			search.o : search.c defs.h buffer.h 
				cc -c search.c 
			files.o : files.c defs.h buffer.h command.h 
				cc -c files.c 
			utils.o : utils.c defs.h 
				cc -c utils.c 
			clean : 
				rm edit $(OBJECTS)
		```
	* letting `make` deduce the commands 
		* it is not necessary to explicitly tell make to compile c source 
			* has an implecit rule for updating `.o` files from a corresponding named `.c` file 
				* uses `cc -c`
			* when using this implecit rule we can also omit it from the prerequisit 
			* optimized code:
			```
				OBJECTS	= main.o kbd.o command.o display.o insert.o search.o files.o utils.o 

				edit : $(OBJECTS)
					cc -o edit $(OBJECTS)
				
				main.o : defs.h 
				kbd.o : defs.h command.h
				command.o : defs.h command.h
				display.o : defs.h buffer.h 
				insert.o : defs.h buffer.h 
				search.o : defs.h buffer.h 
				files.o : defs.h buffer.h command.h
				utils.o : defs.h

				.PHONY : clean
				clean : 
					-rm edit $(OBJECTS)
			```
	* rules for cleaning the directory 
		* do more than compile files 
			* delete files simple
				```
					clean: 
						rm edit $(OBJECTS)
				```
			* delete files complext 
				```
					.PHONY : clean
					clean: 
						-rm edit $(OBJECTS)
				```
				* prevents make from getting confused by errors 




